import logging
import os
import re 
from telegram import (
    Update, InlineKeyboardMarkup, InlineKeyboardButton
)
from telegram.ext import (
    Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
)
from parser import get_random_question
from db import init_db, increment_score, get_top_users
from utils import start_timer, format_hint, user_sessions, normalize_answer
from associations import start_drift_session, add_association, stop_drift_session, drift_sessions

# Get bot token from environment variable
BOT_TOKEN = os.getenv("BOT_TOKEN")
if not BOT_TOKEN:
    raise ValueError("No BOT_TOKEN provided. Set the BOT_TOKEN environment variable.")

ENABLE_HINTS = os.getenv("ENABLE_HINTS", "true").lower() == "true"

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# User mode storage
user_modes = {}  # user_id -> mode

MODES = {
    "normal": "–û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º",
    "speed": "–ù–∞ —Å–∫–æ—Ä–æ—Å—Ç—å",
    "no_hints": "–ë–µ–∑ –ø–æ–¥—Å–∫–∞–∑–æ–∫",
    "drift": "–ê—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω—ã–π –¥—Ä–∏—Ñ—Ç"
}

# Time settings for different modes (in seconds)
MODE_TIMES = {
    "normal": 60,
    "speed": 30,
    "no_hints": 50
}


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("üéÆ –í—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º", callback_data="choose_mode")],
        [InlineKeyboardButton("üé≤ –ù–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å", callback_data="new_question")],
        [InlineKeyboardButton("üèÜ –†–µ–π—Ç–∏–Ω–≥", callback_data="show_rating")]
    ]
    await update.message.reply_text("–ü—Ä–∏–≤–µ—Ç! –Ø Brain Blast üß†‚ö° –ë–æ—Ç –¥–ª—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ –º—ã—à–ª–µ–Ω–∏—è!", reply_markup=InlineKeyboardMarkup(keyboard))


async def choose_mode(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    keyboard = [
        [InlineKeyboardButton("üß† –û–±—ã—á–Ω—ã–π - 60 —Å–µ–∫.", callback_data="set_mode:normal")],
        [InlineKeyboardButton("‚ö° –ù–∞ —Å–∫–æ—Ä–æ—Å—Ç—å - 30 —Å–µ–∫.", callback_data="set_mode:speed")],
        [InlineKeyboardButton("üîï –ë–µ–∑ –ø–æ–¥—Å–∫–∞–∑–æ–∫ - 50 —Å–µ–∫.", callback_data="set_mode:no_hints")],
        [InlineKeyboardButton("üåä –ê—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω—ã–π –¥—Ä–∏—Ñ—Ç (beta)", callback_data="set_mode:drift")]
    ]
    await query.edit_message_text("–í—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏:", reply_markup=InlineKeyboardMarkup(keyboard))


async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data.startswith("set_mode:"):
        mode = query.data.split(":")[1]
        user_id = query.from_user.id
        user_modes[user_id] = mode
        
        # Special handling for drift mode
        if mode == "drift":
            # Clean any existing sessions for this user
            if user_id in drift_sessions:
                del drift_sessions[user_id]
            if user_id in user_sessions:
                del user_sessions[user_id]
                
            # Start a new drift session
            start_word = start_drift_session(user_id)
            
            await query.edit_message_text(
                f"‚úÖ –†–µ–∂–∏–º —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {MODES[mode]}\n\n"
                f"üåä –ê—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω—ã–π –¥—Ä–∏—Ñ—Ç –∑–∞–ø—É—â–µ–Ω!\n\n"
                f"–Ø –Ω–∞—á–∏–Ω–∞—é —Å: *{start_word}*\n\n"
                f"–ù–∞–ø–∏—à–∏ —Å–≤–æ—é –∞—Å—Å–æ—Ü–∏–∞—Ü–∏—é –∫ —ç—Ç–æ–º—É —Å–ª–æ–≤—É.\n"
                f"–í–≤–µ–¥–∏ /stop —á—Ç–æ–±—ã –∑–∞–≤–µ—Ä—à–∏—Ç—å —Å–µ—Å—Å–∏—é.",
                parse_mode="Markdown"
            )
            return
        
        # Normal mode handling for other modes
        # Display main menu buttons after mode selection
        keyboard = [
            [InlineKeyboardButton("üéÆ –í—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º", callback_data="choose_mode")],
            [InlineKeyboardButton("üé≤ –ù–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å", callback_data="new_question")],
            [InlineKeyboardButton("üèÜ –†–µ–π—Ç–∏–Ω–≥", callback_data="show_rating")]
        ]
        await query.edit_message_text(
            f"‚úÖ –†–µ–∂–∏–º —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {MODES[mode]}\n\n–ß—Ç–æ —Ö–æ—á–µ—à—å –¥–µ–ª–∞—Ç—å –¥–∞–ª—å—à–µ?", 
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return

    if query.data == "choose_mode":
        await choose_mode(update, context)
        return

    if query.data == "new_question":
        user_id = query.from_user.id
        
        # Check if user is in drift mode and stop the session
        if user_modes.get(user_id) == "drift" and user_id in drift_sessions:
            # Get the chain before stopping
            chain = stop_drift_session(user_id)
            
            # Log that the drift session was stopped by clicking "New question"
            logging.info(f"User {user_id} stopped drift session by clicking 'New question' button")
            
            # Switch mode back to normal
            user_modes[user_id] = "normal"
        
        mode = user_modes.get(user_id, "normal")
        q = get_random_question()

        # Error check
        if not q.get("question") or "–æ—à–∏–±–∫–∞" in q.get("answer", "").lower():
            await query.message.reply_text("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –≤–æ–ø—Ä–æ—Å–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –ø–æ–∑–∂–µ.")
            return
        
        # Save the question in user session
        user_sessions[user_id] = {"q": q, "mode": mode, "answered": False}
        
        # Handle questions with images
        image_urls = q.get("image_urls", [])
        
        # Prepare question text with metadata
        question_text = f"‚ùì –í–æ–ø—Ä–æ—Å:\n{q['question']}"
        
        # Add metadata if available
        if q.get("metadata_text"):
            question_text += f"\n\n{q['metadata_text']}"
        
        # Add direct link to the question if available
        if q.get("question_url"):
            question_text += f"\n\nüîó [–°—Å—ã–ª–∫–∞ –Ω–∞ –≤–æ–ø—Ä–æ—Å –≤ –±–∞–∑–µ]({q['question_url']})"
        
        if image_urls:
            # First send the question text with metadata
            await query.message.reply_text(question_text, parse_mode="Markdown", disable_web_page_preview=True)
            
            # Then send each image
            for img_url in image_urls:
                try:
                    await query.message.reply_photo(
                        photo=img_url,
                        caption="üì∑ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫ –≤–æ–ø—Ä–æ—Å—É"
                    )
                except Exception as e:
                    logging.error(f"Error sending image {img_url}: {e}")
                    await query.message.reply_text(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: {img_url}")
        else:
            # No images, just send the text with metadata
            await query.message.reply_text(question_text, parse_mode="Markdown", disable_web_page_preview=True)
        
        # Start the timer for this question
        await start_timer(query.message.chat_id, context, user_id, q, mode)

    if query.data == "show_rating":
        top = get_top_users()
        if not top:
            await query.message.reply_text("–†–µ–π—Ç–∏–Ω–≥ –ø–æ–∫–∞ –ø—É—Å—Ç.")
            return
        text = "\n".join([f"{i+1}. {name} ‚Äî {score}" for i, (name, score) in enumerate(top)])
        await query.message.reply_text(f"üèÜ –¢–æ–ø –∏–≥—Ä–æ–∫–æ–≤:\n{text}")
        
    if query.data.startswith("reveal_answer:"):
        user_id = int(query.data.split(":")[1])
        logging.info(f"Processing reveal_answer for user {user_id}")
        chat_id = query.message.chat_id
        
        # Get session data
        session = user_sessions.get(user_id, {})
        
        if session and "q" in session:
            answer = session["q"]["answer"]
            comment = session["q"].get("comment") or "–ë–µ–∑ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è."
            
            # Add buttons for continuing or returning to menu
            keyboard = [
                [InlineKeyboardButton("üé≤ –ù–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å", callback_data="new_question")],
                [InlineKeyboardButton("üîÑ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∏—Ç–µ—Ä–∞—Ü–∏—é?", callback_data="continue_iteration")],
                [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="main_menu")],
            ]
            
            try:
                # Use context.bot.send_message instead of query.message.reply_text
                await context.bot.send_message(
                    chat_id,
                    f"üìù –û—Ç–≤–µ—Ç: {answer}\nüí¨ {comment}", 
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                logging.info(f"Sent answer reveal message to user {user_id}")
            except Exception as e:
                logging.error(f"Error sending reveal answer message: {e}", exc_info=True)
                try:
                    # Try with simpler message if fails
                    await context.bot.send_message(
                        chat_id,
                        f"üìù –û—Ç–≤–µ—Ç: {answer}"
                    )
                except Exception as e2:
                    logging.error(f"Failed to send even simple answer reveal: {e2}")
        else:
            logging.warning(f"Session not found for user {user_id} in reveal_answer")
            try:
                await context.bot.send_message(
                    chat_id,
                    "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–æ–ø—Ä–æ—Å–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–ø—Ä–æ—Å–∏—Ç—å –Ω–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å."
                )
            except Exception as e:
                logging.error(f"Failed to send session not found message: {e}")

    if query.data == "continue_iteration":
        user_id = query.from_user.id
        mode = user_modes.get(user_id, "normal")
        q = get_random_question()

        # Error check
        if not q.get("question") or "–æ—à–∏–±–∫–∞" in q.get("answer", "").lower():
            await query.message.reply_text("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –≤–æ–ø—Ä–æ—Å–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –ø–æ–∑–∂–µ.")
            return
        
        # Save the question in user session
        user_sessions[user_id] = {"q": q, "mode": mode, "answered": False}
        
        # Handle questions with images
        image_urls = q.get("image_urls", [])
        
        # Prepare question text with metadata
        question_text = f"‚ùì –í–æ–ø—Ä–æ—Å:\n{q['question']}"
        
        # Add metadata if available
        if q.get("metadata_text"):
            question_text += f"\n\n{q['metadata_text']}"
        
        # Add direct link to the question if available
        if q.get("question_url"):
            question_text += f"\n\nüîó [–°—Å—ã–ª–∫–∞ –Ω–∞ –≤–æ–ø—Ä–æ—Å –≤ –±–∞–∑–µ]({q['question_url']})"
        
        if image_urls:
            # First send the question text with metadata
            await query.message.reply_text(question_text, parse_mode="Markdown", disable_web_page_preview=True)
            
            # Then send each image
            for img_url in image_urls:
                try:
                    await query.message.reply_photo(
                        photo=img_url,
                        caption="üì∑ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫ –≤–æ–ø—Ä–æ—Å—É"
                    )
                except Exception as e:
                    logging.error(f"Error sending image {img_url}: {e}")
                    await query.message.reply_text(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: {img_url}")
        else:
            # No images, just send the text with metadata
            await query.message.reply_text(question_text, parse_mode="Markdown", disable_web_page_preview=True)
        
        # Start the timer for this question
        await start_timer(query.message.chat_id, context, user_id, q, mode)
        
    if query.data == "main_menu":
        keyboard = [
            [InlineKeyboardButton("üéÆ –í—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º", callback_data="choose_mode")],
            [InlineKeyboardButton("üé≤ –ù–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å", callback_data="new_question")],
            [InlineKeyboardButton("üèÜ –†–µ–π—Ç–∏–Ω–≥", callback_data="show_rating")]
        ]
        await query.edit_message_text("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é Brain Blast üß†‚ö°", reply_markup=InlineKeyboardMarkup(keyboard))


async def handle_answer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Completely rewritten handle_answer function to fix all issues with answer processing
    """
    # Basic info extraction
    user_id = update.message.from_user.id
    name = update.message.from_user.full_name
    user_answer = update.message.text.strip()
    chat_id = update.message.chat_id
    
    logging.info(f"ANSWER RECEIVED: User {user_id} ({name}) submitted: '{user_answer}'")
    
    # 1. Check if user has an active session
    session = user_sessions.get(user_id)
    if not session or "q" not in session:
        logging.error(f"No active session/question for user {user_id}")
        await context.bot.send_message(
            chat_id=chat_id,
            text="ü§î –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞. –ù–∞–∂–º–∏—Ç–µ '–ù–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å', —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å."
        )
        return
    
    # 2. Check if user already answered correctly
    if session.get("correct_answer", False):
        logging.info(f"User {user_id} already answered correctly")
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚úÖ –í—ã —É–∂–µ –æ—Ç–≤–µ—Ç–∏–ª–∏ –≤–µ—Ä–Ω–æ –Ω–∞ —ç—Ç–æ—Ç –≤–æ–ø—Ä–æ—Å."
        )
        return
        
    # Get the correct answer from the session
    correct_answer = session["q"].get("answer", "")
    if not correct_answer:
        logging.error(f"No answer found in question for user {user_id}")
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–ø—Ä–æ—Å–∏—Ç—å –Ω–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å."
        )
        return
        
    logging.info(f"Checking user answer: '{user_answer}' against correct: '{correct_answer}'")
    
    # 3. Process the answer - completely rewritten logic
    is_correct = False
    
    # 3.1 Handle duplex (multi-part) questions
    if "1." in correct_answer and "2." in correct_answer:
        logging.info(f"Processing multi-part (duplex) question")
        
        # Direct match first
        if user_answer.lower() == correct_answer.lower():
            is_correct = True
            logging.info("CORRECT: Direct match on multi-part question")
        
        # If not direct match, try part-by-part matching
        elif "1." in user_answer and "2." in user_answer:
            # Extract parts from both answers
            correct_parts = re.split(r'\d\.', correct_answer.lower())
            user_parts = re.split(r'\d\.', user_answer.lower()) 
            
            # Remove empty parts
            correct_parts = [p.strip() for p in correct_parts if p.strip()]
            user_parts = [p.strip() for p in user_parts if p.strip()]
            
            # Check if we have the same number of parts
            if len(correct_parts) == len(user_parts):
                # Check each part
                all_parts_match = True
                for i in range(len(correct_parts)):
                    c_part = normalize_answer(correct_parts[i])
                    u_part = normalize_answer(user_parts[i])
                    
                    # If any part doesn't match, the answer is wrong
                    if not (u_part == c_part or u_part in c_part or c_part in u_part):
                        all_parts_match = False
                        break
                
                if all_parts_match:
                    is_correct = True
                    logging.info("CORRECT: All parts of multi-part question match")
    
    # 3.2 Handle regular (single) answers
    else:
        clean_correct = normalize_answer(correct_answer)
        clean_user = normalize_answer(user_answer)
        
        # Direct normalization match
        if clean_user == clean_correct:
            is_correct = True
            logging.info("CORRECT: Exact normalized match")
        
        # One contains the other
        elif clean_user in clean_correct or clean_correct in clean_user:
            is_correct = True
            logging.info("CORRECT: One answer contains the other")
            
        # Raw lowercased match
        elif user_answer.lower() == correct_answer.lower():
            is_correct = True
            logging.info("CORRECT: Raw lowercase match")
            
        # Keyword matching for multi-word answers
        elif ' ' in clean_correct and ' ' in clean_user:
            correct_keywords = set(clean_correct.split())
            user_keywords = set(clean_user.split())
            
            if len(correct_keywords) > 1 and len(user_keywords) > 0:
                common_words = correct_keywords.intersection(user_keywords)
                match_percentage = len(common_words) / len(correct_keywords)
                logging.info(f"Keyword match percentage: {match_percentage:.2f}")
                
                if match_percentage >= 0.7:
                    is_correct = True
                    logging.info("CORRECT: Keyword match percentage >= 70%")
        
        # Check comment for alternative answers
        if not is_correct:
            comment = session["q"].get("comment", "").lower()
            if comment and clean_user in comment:
                acceptance_indicators = [
                    "—Ç–∞–∫–∂–µ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç—Å—è", "–∑–∞—Å—á–∏—Ç—ã–≤–∞—Ç—å", "–ø—Ä–∏–Ω–∏–º–∞—Ç—å", 
                    "–∑–∞—á–µ—Ç", "–∑–∞—á—ë—Ç", "–∑–∞—á–∏—Ç—ã–≤–∞—Ç—å", "—ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç"
                ]
                for indicator in acceptance_indicators:
                    if indicator in comment:
                        is_correct = True
                        logging.info(f"CORRECT: Alternative answer accepted based on comment")
                        break
    
    # 4. Cancel timer if it exists
    if session.get("timer_task") and not session.get("timer_task").done():
        try:
            session["timer_task"].cancel()
            session["timer_task"] = None
            logging.info(f"Timer cancelled for user {user_id}")
        except Exception as e:
            logging.error(f"Error cancelling timer: {e}")
    
    # 5. Process result and send feedback
    if is_correct:
        # Update session
        user_sessions[user_id]["answered"] = True
        user_sessions[user_id]["correct_answer"] = True
        
        # Update score
        increment_score(user_id, name)
        logging.info(f"Score incremented for user {user_id}")
        
        # Prepare response
        comment = session["q"].get("comment", "–ë–µ–∑ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è.")
        response = f"‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ! –í—ã –æ—Ç–≤–µ—Ç–∏–ª–∏ –≤–µ—Ä–Ω–æ.\n\nüìù –û—Ç–≤–µ—Ç: {correct_answer}\nüí¨ {comment}"
        
        # Send response
        try:
            await context.bot.send_message(chat_id=chat_id, text=response)
            logging.info(f"SENT CORRECT ANSWER MESSAGE to user {user_id}")
        except Exception as e:
            logging.error(f"Failed to send correct answer message: {e}")
            # Try simpler message
            try:
                await context.bot.send_message(chat_id=chat_id, text="‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ!")
            except:
                logging.error("Failed to send even simple correct message")
    else:
        # Allow user to try again
        user_sessions[user_id]["answered"] = False
        
        # Send incorrect message
        try:
            await context.bot.send_message(chat_id=chat_id, text="‚ùå –ù–µ–≤–µ—Ä–Ω–æ, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑!")
            logging.info(f"SENT INCORRECT MESSAGE to user {user_id}")
        except Exception as e:
            logging.error(f"Failed to send incorrect message: {e}")

def get_small_hint(answer):
    """Provides a small hint about the answer without giving too much away"""
    answer = answer.lower()
    
    if len(answer) < 5:
        return f"–û—Ç–≤–µ—Ç —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ {len(answer)} –±—É–∫–≤"
    
    # For longer answers, hint at first and last letters
    first = answer[0].upper()
    last = answer[-1]
    
    # For multi-word answers
    if ' ' in answer:
        words = answer.split()
        return f"–û—Ç–≤–µ—Ç —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ {len(words)} —Å–ª–æ–≤"
        
    return f"–û—Ç–≤–µ—Ç –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –Ω–∞ '{first}' –∏ –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è –Ω–∞ '{last}'"

async def start_drift(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Command handler to start a new associative drift session"""
    user_id = update.message.from_user.id
    # Set user mode to drift
    user_modes[user_id] = "drift"
    
    # Clean any existing sessions
    if user_id in drift_sessions:
        del drift_sessions[user_id]
    if user_id in user_sessions:
        del user_sessions[user_id]
    
    # Start a new drift session
    start_word = start_drift_session(user_id)
    
    await update.message.reply_text(
        f"üåä *–ê—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω—ã–π –¥—Ä–∏—Ñ—Ç* –∑–∞–ø—É—â–µ–Ω!\n\n"
        f"–Ø –Ω–∞—á–∏–Ω–∞—é —Å: *{start_word}*\n\n"
        f"–ù–∞–ø–∏—à–∏ —Å–≤–æ—é –∞—Å—Å–æ—Ü–∏–∞—Ü–∏—é –∫ —ç—Ç–æ–º—É —Å–ª–æ–≤—É.\n"
        f"–í–≤–µ–¥–∏ /stop —á—Ç–æ–±—ã –∑–∞–≤–µ—Ä—à–∏—Ç—å —Å–µ—Å—Å–∏—é.",
        parse_mode="Markdown"
    )

async def stop_drift(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Command handler to stop the current drift session"""
    user_id = update.message.from_user.id
    
    if user_id not in drift_sessions:
        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π —Å–µ—Å—Å–∏–∏ –∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ–≥–æ –¥—Ä–∏—Ñ—Ç–∞.")
        return
    
    # Get the complete chain
    chain = stop_drift_session(user_id)
    
    # Format the chain nicely
    formatted_chain = ' ‚Üí '.join(chain)
    
    # Create keyboard for options after stopping
    keyboard = [
        [InlineKeyboardButton("üåä –ù–æ–≤—ã–π –¥—Ä–∏—Ñ—Ç", callback_data="set_mode:drift")],
        [InlineKeyboardButton("üéÆ –í—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º", callback_data="choose_mode")],
        [InlineKeyboardButton("üé≤ –ù–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å", callback_data="new_question")]
    ]
    
    await update.message.reply_text(
        f"üèÅ –°–µ—Å—Å–∏—è –∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ–≥–æ –¥—Ä–∏—Ñ—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\n\n"
        f"–¶–µ–ø–æ—á–∫–∞ –∞—Å—Å–æ—Ü–∏–∞—Ü–∏–π:\n*{formatted_chain}*\n\n"
        f"–ß—Ç–æ —Ö–æ—Ç–∏—Ç–µ –¥–µ–ª–∞—Ç—å –¥–∞–ª—å—à–µ?",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Main message handler that routes messages to either the CHGK answer handler
    or the associative drift handler based on the user's current mode
    """
    user_id = update.message.from_user.id
    message_text = update.message.text.strip()
    
    # Check if user is in drift mode
    if user_modes.get(user_id) == "drift" and user_id in drift_sessions:
        # If in drift mode, check for stop commands first
        if message_text.startswith('/'):
            # If user types /stop, this is handled by the stop_drift command handler
            # If user types /start, we should also exit drift mode
            if message_text.startswith('/start'):
                # Get the chain before stopping
                chain = stop_drift_session(user_id)
                
                # Format the chain and show completion message with options
                formatted_chain = ' ‚Üí '.join(chain)
                
                keyboard = [
                    [InlineKeyboardButton("üéÆ –í—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º", callback_data="choose_mode")],
                    [InlineKeyboardButton("üé≤ –ù–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å", callback_data="new_question")]
                ]
                
                await update.message.reply_text(
                    f"üèÅ –°–µ—Å—Å–∏—è –∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ–≥–æ –¥—Ä–∏—Ñ—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–æ–π /start\n\n"
                    f"–¶–µ–ø–æ—á–∫–∞ –∞—Å—Å–æ—Ü–∏–∞—Ü–∏–π:\n*{formatted_chain}*\n\n"
                    f"–ß—Ç–æ —Ö–æ—Ç–∏—Ç–µ –¥–µ–ª–∞—Ç—å –¥–∞–ª—å—à–µ?",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode="Markdown"
                )
                return
            # For other commands, let them be handled by command handlers
            return
            
        # Process the user's association and get the bot's response
        next_word = add_association(user_id, message_text)
        
        # Send the next association
        await update.message.reply_text(
            f"üëâ *{next_word}*",
            parse_mode="Markdown"
        )
        return
    
    # Otherwise, handle as a CHGK quiz answer
    await handle_answer(update, context)

def main():
    """Start the bot."""
    # Initialize database
    init_db()
    
    # Build application
    application = Application.builder().token(BOT_TOKEN).build()
    
    # Add handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("drift", start_drift))
    application.add_handler(CommandHandler("stop", stop_drift))
    application.add_handler(CallbackQueryHandler(button_handler))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    # Start the bot
    print("Starting bot...")
    application.run_polling(drop_pending_updates=True)

if __name__ == "__main__":
    main()

